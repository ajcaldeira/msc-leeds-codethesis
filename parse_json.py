## This file parses the raw json from the API and 
import pandas as pd
import json
import os
import pandasql
import glob
from measure_pressure import ParseTimelinePressure
## Takes in: RAW Json Formatted file for the high level match data
## A lot of the variables in here are NOT used, but they are kept just incase - no harm
def Parse_match(matchData):
    ## Parse the json files and create a dataframe with all the required fields
    puuidDict = {}
    dictList = []
    for i in range(10):
        curentParticipant = matchData['info']['participants'][i]
        curentGame = matchData['info']
        curentGameMetadata = matchData['metadata']
        puuidDict = {}
        puuidDict['gameId'] = curentGameMetadata['matchId']
        puuidDict['gameDuration'] = (curentGame['gameDuration'] / 60000) #convert ms to mins
        puuidDict['puuid'] = curentParticipant['puuid']
        puuidDict['summonerId'] = curentParticipant['summonerId']
        puuidDict['teamId'] = curentParticipant['teamId']
        puuidDict['win'] = curentParticipant['win'] 
        puuidDict['teamPosition'] = curentParticipant['teamPosition']
        puuidDict['champExperience'] = curentParticipant['champExperience']
        puuidDict['kills'] = curentParticipant['kills']
        puuidDict['assists'] = curentParticipant['assists']
        puuidDict['turretKills'] = curentParticipant['turretKills']
        puuidDict['epicMonsterKills'] = curentParticipant['baronKills'] + curentParticipant['dragonKills']
        puuidDict['visionScore'] = curentParticipant['visionScore']
        puuidDict['visionWardsBoughtInGame'] = curentParticipant['visionWardsBoughtInGame']
        puuidDict['magicDamageDealtToChampions'] = curentParticipant['magicDamageDealtToChampions']
        puuidDict['deaths'] = curentParticipant['deaths']
        puuidDict['totalMinionsKilled'] = curentParticipant['totalMinionsKilled']
        puuidDict['timeCCingOthers'] = curentParticipant['timeCCingOthers']
        puuidDict['totalDamageTaken'] = curentParticipant['totalDamageTaken']
        puuidDict['totalHealsOnTeammates'] = curentParticipant['totalHealsOnTeammates']
        puuidDict['totalTimeSpentDead'] = curentParticipant['totalTimeSpentDead']
        puuidDict['goldEarned'] = curentParticipant['goldEarned']
        puuidDict['objectivesStolen'] = curentParticipant['objectivesStolen']
        puuidDict['objectivesStolenAssists'] = curentParticipant['objectivesStolenAssists']
        
        dictList.append(puuidDict)

    df = pd.DataFrame(dictList)
    return df

## Function to join the tables generated by parsing the Timeframe json
def JoinTimelineTables(dfParticipants,dfAssist,dfTower,dfMonster,dfPressure):

    sql = '''
    SELECT puuid, participantId, participantsAssisted, towerKillsAssisted, monsterKillsAssisted, participantsAssistedWithPressure
    FROM dfParticipants
    INNER JOIN dfAssist
        ON dfParticipants.participantId = dfAssist.participant
    INNER JOIN dfTower
        ON dfParticipants.participantId = dfTower.participant
    INNER JOIN dfMonster
        ON dfParticipants.participantId = dfMonster.participant
    INNER JOIN dfPressure
        ON dfParticipants.participantId = dfPressure.participant
    '''
    dfFinal = pandasql.sqldf(sql, locals())
    return dfFinal


## Parse the timeline data
## Takes in: RAW Json Formatted file for the timeline
def Parse_Timeline(match_timeline):
    
    ## Get the participant ID by puuid
    dfParticipants = pd.DataFrame(match_timeline['info']['participants'])
    matchFrames = match_timeline['info']['frames']

    ## Init 2 dictionaries to store the killer and who assisted the killer
    killAssistDict = {} # killer (key) and assisting participants (value)
    finalAssistDict = {} # participants (key) and who they assisted (value)

    towerAssistDict = {} # killer (key) and assisting participants (value)
    finalTowerAssistDict = {} # participants (key) and who they assisted (value)

    monsterAssistDict = {} # killer (key) and assisting participants (value)
    finalMonsterAssistDict = {} # participants (key) and who they assisted (value)

    allAssistsCnt = 0
    allAssistsCntLst = []

    ## init
    for i in range(1,11):
        killAssistDict[str(i)] = []
        finalAssistDict[str(i)] = []
        towerAssistDict[str(i)] = []
        finalTowerAssistDict[str(i)] = []
        monsterAssistDict[str(i)] = []
        finalMonsterAssistDict[str(i)] = []

    ## Loop through each frame of the game (1 minute intervals)
    ## This is a very complex function:
    ## 1. It loops through every event that occured during the game, looking for:
    ##    player kills, tower kills and elite monster kills
    ## 2. Once an event (fromt he above) is found, it notes the players that assisted the kill
    ## 3. A dataframe is crated for each metric
    ## 4. Finally the dataframes are all joined together, along with the pressure measure from 
    ##    measure_pressure.py ParseTimelinePressure()
    for frame in matchFrames:
        currentEventList = frame['events']
        ## Loop through each event in the time frame
        for event in currentEventList:
            ## Looking for the type of event
            if event['type'] == 'CHAMPION_KILL':
                try: #trying incase there was no assisting participant
                    for assistingParticipant in event['assistingParticipantIds']:
                        killAssistDict[str(event['killerId'])].append(assistingParticipant)
                        allAssistsCnt+=1
                except:
                    if event['killerId'] == 0: # Nobody killed the champion, they were EXECUTED
                        pass
                    else:
                        killAssistDict[str(event['killerId'])].append(-1) # use -1 if it was a solo kill
            elif event['type'] == 'BUILDING_KILL':
                try: #trying incase there was no assisting participant
                    for assistingParticipant in event['assistingParticipantIds']:
                        towerAssistDict[str(event['killerId'])].append(assistingParticipant)
                        allAssistsCnt+=1
                except:
                    if event['killerId'] == 0: # Nobody killed the tower, minions did
                        pass
                    else:
                        towerAssistDict[str(event['killerId'])].append(-1) # use -1 if it was a solo kill
            elif event['type'] == 'ELITE_MONSTER_KILL':
                try: #trying incase there was no assisting participant
                    for assistingParticipant in event['assistingParticipantIds']:
                        monsterAssistDict[str(event['killerId'])].append(assistingParticipant)
                        allAssistsCnt+=1
                except:
                    if event['killerId'] == 0: # Nobody killed the tower, minions did
                        pass
                    else:
                        monsterAssistDict[str(event['killerId'])].append(-1) # use -1 if it was a solo kill

    
    #rearrange the dictionary to have the structure: participants (key) and who they assisted (value)
    for i in range(1,11):
        for pid in killAssistDict[str(i)]:
            if pid > 0:
                finalAssistDict[str(pid)].append(i)
        for pidt in towerAssistDict[str(i)]:
            if pidt > 0:
                finalTowerAssistDict[str(pidt)].append(i)
        for pidm in monsterAssistDict[str(i)]:
            if pidm > 0:
                finalMonsterAssistDict[str(pidm)].append(i)

    
    for i in range(1,11):
        finalAssistDict[str(i)] = str(finalAssistDict[str(i)])
        finalTowerAssistDict[str(i)] = str(finalTowerAssistDict[str(i)])
        finalMonsterAssistDict[str(i)] = str(finalMonsterAssistDict[str(i)])

    ## Convert the dict to a dataframe, fill inf nan with -1 and converting back to int
    
    dfAssist = pd.DataFrame.from_dict(finalAssistDict, orient='index', columns=['participantsAssisted'])
    dfAssist.index.name = 'participant'

    dfTower = pd.DataFrame.from_dict(finalTowerAssistDict, orient='index', columns=['towerKillsAssisted'])
    dfTower.index.name = 'participant'

    dfMonster = pd.DataFrame.from_dict(finalMonsterAssistDict, orient='index', columns=['monsterKillsAssisted'])
    dfMonster.index.name = 'participant'

    ## Call the function from measure_pressure.py to get the dataframe of the custom pressure metric!
    dfPressure = ParseTimelinePressure(match_timeline)

    ## Count the total number of assists per player


    return JoinTimelineTables(dfParticipants, dfAssist, dfTower, dfMonster, dfPressure)

## Join files together!
def JoinMatchAndTimeline(matchDF,timelineDF):
    sql = '''
    SELECT *
    FROM matchDF
    INNER JOIN timelineDF
    ON matchDF.puuid = timelineDF.puuid
    '''
    dfFinal = pandasql.sqldf(sql, locals())
    dfFinal = dfFinal.loc[:,~dfFinal.columns.duplicated()]

    ## APPLY FILTERS
    sql = '''
    SELECT *
    FROM dfFinal
    WHERE gameDuration > 23
    ORDER BY gameId asc
    '''
    dfFinal = pandasql.sqldf(sql, locals())

    return dfFinal

#Requires a list with the index 'rank'
## assigning a numerical value to the ranks
def CalculateAvgRank(listOfRanks,indexOfRankCol):
    rankedDict = {
        'NA':0,
        'IRON-IV':1,
        'IRON-III':2,
        'IRON-II':3,
        'IRON-I':4,
        'BRONZE-IV':5,
        'BRONZE-III':6,
        'BRONZE-II':7,
        'BRONZE-I':8,
        'SILVER-IV':9,
        'SILVER-III':10,
        'SILVER-II':11,
        'SILVER-I':12,
        'GOLD-IV':13,
        'GOLD-III':14,
        'GOLD-II':15,
        'GOLD-I':16,
        'PLATINUM-IV':17,
        'PLATINUM-III':18,
        'PLATINUM-II':19,
        'PLATINUM-I':20,
        'DIAMOND-IV':21,
        'DIAMOND-III':22,
        'DIAMOND-II':23,
        'DIAMOND-I':24,
        'MASTER-I':25,
        'GRANDMASTER-I':26,
        'CHALLENGER-I':27
    }

    playerCounter = 0
    totalRank = 0
    naCount = 0
    finalList = []
    cnt = 0

    for player in listOfRanks:
        playerRank = player[indexOfRankCol]
        if playerRank == 'NA':
            naCount += 1
        totalRank += int(rankedDict[playerRank])
        playerCounter += 1
        cnt+=1

        if playerCounter == 10: #ALWYAS 10 players
            avgRank = int(round(totalRank / (10 - naCount),0))
            # append it for each player - not efficient, but works
            for i in range(10):
                finalList.append(avgRank)
            ## reset all values
            playerCounter = 0
            naCount = 0
            avgRank = 0
            totalRank = 0

    return finalList


## Used to get a single player's summId from a game ID and participant index
def GetPlayerIdFromGameIdIndex(pathToFile,index):
    index = int(index)
    f = open(pathToFile)
    gameInfo = json.load(f)
    return gameInfo['info']['participants'][index]['summonerId']


## Process the players ranks json files
def ProcessPlayerRanksJson(pathToJsonFiles):
    dfData = []
    counter = 0
    pathToMatchJson = os.path.join(os.getcwd(),'match json files/')
    ## For every file in the ranked folder
    for filename in glob.glob(os.path.join(os.getcwd(),pathToJsonFiles, '*.json')):
  
        f = open(filename)
        playerInfo = json.load(f)
        ## look through each option in the array to make sure were looking at solo ranked games only
        # Get the game ID
        ogGameId = filename.rsplit('/')[-1].rsplit("_")
        gameId = ogGameId[0] + "_" + ogGameId[1]
        playerIndex = ogGameId[2].split('.')[0]
        if len(playerInfo) < 1: #the player has no ranked info
            dirToMatchFile = pathToMatchJson + gameId + "_match.json"
            summId = GetPlayerIdFromGameIdIndex(dirToMatchFile,int(playerIndex) -1)
            dfData.append([gameId, summId, "NA"]) # append to data list
            counter+=1
            continue #since we have appended to the list, we are finished with the player, so continue
        cnt = 0
        for queue in playerInfo:
            if queue['queueType'] == 'RANKED_SOLO_5x5': #this is the correct queue type
                rank = f"{queue['tier']}-{queue['rank']}" #concat these
                # rank = f"{queue['tier']}" #concat these
                dfData.append([gameId, queue['summonerId'],rank]) # append to data list
                counter+=1
                continue
            cnt+=1
            ## Catch the rest of the items that dont fit the usual criteria
            if len(playerInfo) > 0 and queue['queueType'] != 'RANKED_SOLO_5x5' and cnt == len(playerInfo):
                rank = f"{queue['tier']}-{queue['rank']}" #concat these
                dfData.append([gameId, queue['summonerId'],rank]) # append to data list
                counter+=1

    avgRankList = CalculateAvgRank(dfData,2)
    df = pd.DataFrame(data=dfData, columns =['gameId','summonerId','rank'])

    ## DEBUG PURPOSES ONLY
    # print("counter: ", counter)
    # print("avg rank list len: ", len(avgRankList))
    # print("df shape: ", df.shape[0])
    # print("df data list len: ", len(dfData))

    ## Calculate avg rank
    df['avgrank'] = avgRankList
    df = df[~df.gameId.str.contains("EUN1")]
    newDF = RemoveNaValues(df) #remove games with all NA values
    newDF.to_csv("playerRanks.csv", index=False) ## write to CSV

## Remove bad data
def RemoveNaValues(df):
    gamesToRemove = []
    for index, row in df.iterrows():
        if row['rank'] == "NA":
            gamesToRemove.append(row['gameId'])
    gamesToRemoveDeduped = list(dict.fromkeys(gamesToRemove)) # deduplicate the games to remove

    newDF = df[~df['gameId'].isin(gamesToRemoveDeduped)]

    return newDF




## If the file is called directly.. Mainly for debugging and testing
## If you are nto calling htis file directly, IGNORE THIS
if __name__ == '__main__':
    pass
    # json_file = open("match.json")
    # variables = json.load(json_file)
    # matchDF = Parse_match(variables)

    # json_file = open("timeline.json")
    # match_timeline = json.load(json_file)
    # timelineDF = Parse_Timeline(match_timeline)

    # joinedDF = JoinMatchAndTimeline(matchDF,timelineDF)
    # joinedDF.to_csv('joined.csv',index=False, mode='a')

    # ProcessPlayerRanksJson("rank json files")